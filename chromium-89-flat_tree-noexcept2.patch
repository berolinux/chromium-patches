From 342c5c514b8943d1e1a8a0f86e60227e6509064a Mon Sep 17 00:00:00 2001
From: Jan Wilken Dörrie <jdoerrie@chromium.org>
Date: Thu, 03 Dec 2020 21:31:53 +0000
Subject: [PATCH] [base] Simplify flat_tree's noexcept specification

Following r833080 this change removes the explicit noexcept specifier
from flat_tree's move operations, since the compiler will perform the
expected outcome anyway [1]. Furthermore, this change adds tests to
statically assert the correct behavior.

[1] https://timsong-cpp.github.io/cppwp/n4140/dcl.fct.def.default#2.2

Bug: None
Change-Id: I88cd95bf577899925dd8b07a2865b6d2c6f318ed
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/2567929
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Commit-Queue: Jan Wilken Dörrie <jdoerrie@chromium.org>
Cr-Commit-Position: refs/heads/master@{#833456}
---

diff --git a/base/containers/flat_tree.h b/base/containers/flat_tree.h
index 1cd1b32..733eeda 100644
--- a/base/containers/flat_tree.h
+++ b/base/containers/flat_tree.h
@@ -186,7 +186,7 @@
 
   flat_tree() = default;
   flat_tree(const flat_tree&) = default;
-  flat_tree(flat_tree&&) noexcept = default;
+  flat_tree(flat_tree&&) = default;
 
   explicit flat_tree(const key_compare& comp);
 
@@ -229,8 +229,7 @@
   // Assume that move assignment invalidates iterators and references.
 
   flat_tree& operator=(const flat_tree&) = default;
-  flat_tree& operator=(flat_tree&&) noexcept(
-      std::is_nothrow_move_assignable<container_type>::value) = default;
+  flat_tree& operator=(flat_tree&&) = default;
   // Takes the first if there are duplicates in the initializer list.
   flat_tree& operator=(std::initializer_list<value_type> ilist);
 
diff --git a/base/containers/flat_tree_unittest.cc b/base/containers/flat_tree_unittest.cc
index 21da264..0f8ef520 100644
--- a/base/containers/flat_tree_unittest.cc
+++ b/base/containers/flat_tree_unittest.cc
@@ -199,6 +199,28 @@
                 "RandomAccessIterator is multipass");
 }
 
+// Tests that the compiler generated move operators propagrate noexcept
+// specifiers.
+TEST(FlatTree, NoExcept) {
+  struct MoveThrows {
+    MoveThrows(MoveThrows&&) noexcept(false) {}
+    MoveThrows& operator=(MoveThrows&&) noexcept(false) { return *this; }
+  };
+
+  using MoveThrowsTree = flat_tree<MoveThrows, base::identity, std::less<>,
+                                   std::array<MoveThrows, 1>>;
+
+  static_assert(std::is_nothrow_move_constructible<IntTree>::value,
+                "Error: IntTree is not nothrow move constructible");
+  static_assert(std::is_nothrow_move_assignable<IntTree>::value,
+                "Error: IntTree is not nothrow move assignable");
+
+  static_assert(!std::is_nothrow_move_constructible<MoveThrowsTree>::value,
+                "Error: MoveThrowsTree is nothrow move constructible");
+  static_assert(!std::is_nothrow_move_assignable<MoveThrowsTree>::value,
+                "Error: MoveThrowsTree is nothrow move assignable");
+}
+
 // ----------------------------------------------------------------------------
 // Class.
 
