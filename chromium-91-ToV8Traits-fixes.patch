From cab7934e222f34401569119504227fab1c169dd3 Mon Sep 17 00:00:00 2001
From: Stephan Hartmann <stha09@googlemail.com>
Date: Wed, 17 Mar 2021 15:25:24 +0000
Subject: [PATCH] GCC: fix template specialization in
 ToV8Traits<IDLArray<T>>::ToV8

GCC complains that explicit specialization in non-namespace scope
is happening for ToV8Traits<IDLArray<T>>::ToV8. However, the
specialization isn't needed here so remove it.
---
 third_party/blink/renderer/bindings/core/v8/to_v8_traits.h | 1 -
 1 file changed, 1 deletion(-)

diff --git a/third_party/blink/renderer/bindings/core/v8/to_v8_traits.h b/third_party/blink/renderer/bindings/core/v8/to_v8_traits.h
index 6c79433..0e1f469 100644
--- a/third_party/blink/renderer/bindings/core/v8/to_v8_traits.h
+++ b/third_party/blink/renderer/bindings/core/v8/to_v8_traits.h
@@ -683,7 +683,6 @@ struct ToV8Traits<IDLArray<T>> {
   }
 
   // TODO(crbug.com/1185046): Remove this overload.
-  template <>
   static v8::MaybeLocal<v8::Value> ToV8(
       ScriptState* script_state,
       const Vector<v8::Local<v8::Value>>& value) WARN_UNUSED_RESULT {
-- 
2.26.2

From a38a8d5bcf33fcfb457fad074a42648eb08884bf Mon Sep 17 00:00:00 2001
From: Stephan Hartmann <stha09@googlemail.com>
Date: Wed, 17 Mar 2021 15:58:42 +0000
Subject: [PATCH] GCC: move attribute to the start of function definition

For functions definitions attributes have to be placed
before function name for GCC.
---
 .../renderer/bindings/core/v8/to_v8_traits.h  | 387 ++++++++----------
 1 file changed, 169 insertions(+), 218 deletions(-)

diff --git a/third_party/blink/renderer/bindings/core/v8/to_v8_traits.h b/third_party/blink/renderer/bindings/core/v8/to_v8_traits.h
index 0e1f469..5e90173 100644
--- a/third_party/blink/renderer/bindings/core/v8/to_v8_traits.h
+++ b/third_party/blink/renderer/bindings/core/v8/to_v8_traits.h
@@ -33,9 +33,8 @@ struct ToV8Traits;
 // Any
 template <>
 struct ToV8Traits<IDLAny> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const ScriptValue& script_value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const ScriptValue& script_value) {
     // It is not correct to take empty |script_value|.
     // However, some call sites expect to get v8::Undefined
     // when ToV8 takes empty |script_value|.
@@ -45,9 +44,8 @@ struct ToV8Traits<IDLAny> {
     return script_value.V8Value();
   }
 
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const v8::Local<v8::Value>& value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const v8::Local<v8::Value>& value) {
     // TODO(crbug.com/1183637): Remove this if-branch.
     if (value.IsEmpty())
       return v8::Undefined(script_state->GetIsolate());
@@ -58,8 +56,8 @@ struct ToV8Traits<IDLAny> {
 // Boolean
 template <>
 struct ToV8Traits<IDLBoolean> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        bool value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, bool value) {
     return v8::Boolean::New(script_state->GetIsolate(), value);
   }
 };
@@ -68,8 +66,8 @@ struct ToV8Traits<IDLBoolean> {
 // int8_t
 template <bindings::IDLIntegerConvMode mode>
 struct ToV8Traits<IDLIntegerTypeBase<int8_t, mode>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        int8_t value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, int8_t value) {
     return v8::Integer::New(script_state->GetIsolate(), value);
   }
 };
@@ -77,8 +75,8 @@ struct ToV8Traits<IDLIntegerTypeBase<int8_t, mode>> {
 // int16_t
 template <bindings::IDLIntegerConvMode mode>
 struct ToV8Traits<IDLIntegerTypeBase<int16_t, mode>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        int16_t value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, int16_t value) {
     return v8::Integer::New(script_state->GetIsolate(), value);
   }
 };
@@ -86,8 +84,8 @@ struct ToV8Traits<IDLIntegerTypeBase<int16_t, mode>> {
 // int32_t
 template <bindings::IDLIntegerConvMode mode>
 struct ToV8Traits<IDLIntegerTypeBase<int32_t, mode>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        int32_t value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, int32_t value) {
     return v8::Integer::New(script_state->GetIsolate(), value);
   }
 };
@@ -95,8 +93,8 @@ struct ToV8Traits<IDLIntegerTypeBase<int32_t, mode>> {
 // int64_t
 template <bindings::IDLIntegerConvMode mode>
 struct ToV8Traits<IDLIntegerTypeBase<int64_t, mode>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        int64_t value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, int64_t value) {
     int32_t value_in_32bit = static_cast<int32_t>(value);
     if (value_in_32bit == value)
       return v8::Integer::New(script_state->GetIsolate(), value_in_32bit);
@@ -108,8 +106,8 @@ struct ToV8Traits<IDLIntegerTypeBase<int64_t, mode>> {
 // uint8_t
 template <bindings::IDLIntegerConvMode mode>
 struct ToV8Traits<IDLIntegerTypeBase<uint8_t, mode>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        uint8_t value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, uint8_t value) {
     return v8::Integer::NewFromUnsigned(script_state->GetIsolate(), value);
   }
 };
@@ -117,8 +115,8 @@ struct ToV8Traits<IDLIntegerTypeBase<uint8_t, mode>> {
 // uint16_t
 template <bindings::IDLIntegerConvMode mode>
 struct ToV8Traits<IDLIntegerTypeBase<uint16_t, mode>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        uint16_t value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, uint16_t value) {
     return v8::Integer::NewFromUnsigned(script_state->GetIsolate(), value);
   }
 };
@@ -126,8 +124,8 @@ struct ToV8Traits<IDLIntegerTypeBase<uint16_t, mode>> {
 // uint32_t
 template <bindings::IDLIntegerConvMode mode>
 struct ToV8Traits<IDLIntegerTypeBase<uint32_t, mode>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        uint32_t value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, uint32_t value) {
     return v8::Integer::NewFromUnsigned(script_state->GetIsolate(), value);
   }
 };
@@ -135,8 +133,8 @@ struct ToV8Traits<IDLIntegerTypeBase<uint32_t, mode>> {
 // uint64_t
 template <bindings::IDLIntegerConvMode mode>
 struct ToV8Traits<IDLIntegerTypeBase<uint64_t, mode>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        uint64_t value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, uint64_t value) {
     uint32_t value_in_32bit = static_cast<uint32_t>(value);
     if (value_in_32bit == value) {
       return v8::Integer::NewFromUnsigned(script_state->GetIsolate(),
@@ -150,8 +148,8 @@ struct ToV8Traits<IDLIntegerTypeBase<uint64_t, mode>> {
 // Floating Point Number
 template <typename T, bindings::IDLFloatingPointNumberConvMode mode>
 struct ToV8Traits<IDLFloatingPointNumberTypeBase<T, mode>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        T value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, T value) {
     return v8::Number::New(script_state->GetIsolate(), value);
   }
 };
@@ -161,9 +159,8 @@ template <typename T>
 struct ToV8Traits<
     T,
     typename std::enable_if_t<std::is_base_of<IDLStringTypeBase, T>::value>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const String& value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const String& value) {
     // if |value| is a null string, V8String() returns an empty string.
     return V8String(script_state->GetIsolate(), value);
   }
@@ -172,9 +169,8 @@ struct ToV8Traits<
 // Object
 template <>
 struct ToV8Traits<IDLObject> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const ScriptValue& script_value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const ScriptValue& script_value) {
     DCHECK(!script_value.IsEmpty());
     v8::Local<v8::Value> v8_value = script_value.V8Value();
     // TODO(crbug.com/1185033): Change this if-branch to DCHECK.
@@ -187,9 +183,8 @@ struct ToV8Traits<IDLObject> {
 // Promise
 template <>
 struct ToV8Traits<IDLPromise> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const ScriptPromise& script_promise)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const ScriptPromise& script_promise) {
     DCHECK(!script_promise.IsEmpty());
     return script_promise.V8Value();
   }
@@ -243,9 +238,8 @@ template <typename T>
 struct ToV8Traits<
     T,
     typename std::enable_if_t<std::is_base_of<ScriptWrappable, T>::value>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        T* script_wrappable)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, T* script_wrappable) {
     return bindings::ToV8HelperScriptWrappable(script_state, script_wrappable);
   }
 
@@ -254,10 +248,10 @@ struct ToV8Traits<
   // which is needed to create a wrapper. If a wrapper object corresponding to
   // the receiver object exists, ToV8 can return it without a call to
   // CreationContext() which is slow.
-  static v8::MaybeLocal<v8::Value> ToV8(
-      v8::Isolate* isolate,
-      T* script_wrappable,
-      v8::Local<v8::Object> creation_context_object) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(v8::Isolate* isolate,
+       T* script_wrappable,
+       v8::Local<v8::Object> creation_context_object) {
     return bindings::ToV8HelperScriptWrappable(isolate, script_wrappable,
                                                creation_context_object);
   }
@@ -268,9 +262,8 @@ template <typename T>
 struct ToV8Traits<T,
                   typename std::enable_if_t<
                       std::is_base_of<bindings::DictionaryBase, T>::value>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const T* dictionary)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const T* dictionary) {
     DCHECK(dictionary);
     v8::Local<v8::Value> v8_value = dictionary->CreateV8Object(
         script_state->GetIsolate(), script_state->GetContext()->Global());
@@ -284,9 +277,8 @@ template <typename T>
 struct ToV8Traits<
     T,
     typename std::enable_if_t<std::is_base_of<IDLDictionaryBase, T>::value>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const T* dictionary)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const T* dictionary) {
     // TODO(crbug.com/1185018): Change this if-branch to DCHECK(dictionary).
     if (!dictionary)
       return v8::Null(script_state->GetIsolate());
@@ -300,8 +292,8 @@ template <typename T>
 struct ToV8Traits<T,
                   typename std::enable_if_t<
                       std::is_base_of<CallbackFunctionBase, T>::value>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        T* callback) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, T* callback) {
     // creation_context (|script_state->GetContext()|) is intentionally ignored.
     // Callback functions are not wrappers nor clonable. ToV8 on a callback
     // function must be used only when it's in the same world.
@@ -316,8 +308,8 @@ template <typename T>
 struct ToV8Traits<T,
                   typename std::enable_if_t<
                       std::is_base_of<CallbackInterfaceBase, T>::value>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        T* callback) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, T* callback) {
     // creation_context (|script_state->GetContext()|) is intentionally ignored.
     // Callback Interfaces are not wrappers nor clonable. ToV8 on a callback
     // interface must be used only when it's in the same world.
@@ -332,24 +324,21 @@ template <typename T>
 struct ToV8Traits<T,
                   typename std::enable_if_t<
                       std::is_base_of<bindings::EnumerationBase, T>::value>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const T& enumeration)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const T& enumeration) {
     return V8String(script_state->GetIsolate(), enumeration.AsCStr());
   }
 
   // TODO(crbug.com/1184543): Remove this overload.
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const String& value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const String& value) {
     DCHECK(!value.IsEmpty());
     return V8String(script_state->GetIsolate(), value);
   }
 
   // TODO(crbug.com/1184543): Remove this overload.
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const AtomicString& value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const AtomicString& value) {
     DCHECK(!value.IsEmpty());
     return V8String(script_state->GetIsolate(), value);
   }
@@ -358,8 +347,8 @@ struct ToV8Traits<T,
 // NotShared
 template <typename T>
 struct ToV8Traits<NotShared<T>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        NotShared<T> value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, NotShared<T> value) {
     DCHECK(!value.IsNull());
     return ToV8Traits<T>::ToV8(script_state, value.Get());
   }
@@ -367,8 +356,8 @@ struct ToV8Traits<NotShared<T>> {
   // TODO(crbug.com/1183647): Remove this overload. It is used in generated
   // code, but it might cause bugs because T* cannot tell whether it's NotShared
   // or MaybeShared.
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        T* value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, T* value) {
     // TODO(canonmukai): Remove this if-branch and add DCHECK(value) instead.
     if (!value)
       return v8::Null(script_state->GetIsolate());
@@ -376,9 +365,8 @@ struct ToV8Traits<NotShared<T>> {
   }
 
   // TODO(canonmukai): Remove this overload.
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const ScriptValue& script_value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const ScriptValue& script_value) {
     DCHECK(!script_value.IsEmpty());
     return ToV8Traits<IDLAny>::ToV8(script_state, script_value);
   }
@@ -387,9 +375,8 @@ struct ToV8Traits<NotShared<T>> {
 // MaybeShared
 template <typename T>
 struct ToV8Traits<MaybeShared<T>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        MaybeShared<T> value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, MaybeShared<T> value) {
     return ToV8Traits<T>::ToV8(script_state, value.Get());
   }
 };
@@ -492,40 +479,35 @@ template <typename T>
 struct ToV8Traits<
     IDLSequence<T>,
     std::enable_if_t<std::is_base_of<bindings::DictionaryBase, T>::value>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const HeapVector<Member<T>>& value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const HeapVector<Member<T>>& value) {
     return bindings::ToV8HelperSequenceWithMemberUpcast<
         bindings::DictionaryBase>(script_state, &value);
   }
 
-  static v8::MaybeLocal<v8::Value> ToV8(
-      ScriptState* script_state,
-      const HeapVector<Member<const T>>& value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const HeapVector<Member<const T>>& value) {
     return bindings::ToV8HelperSequenceWithMemberUpcast<
         bindings::DictionaryBase>(script_state, &value);
   }
 
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const HeapVector<Member<T>>* value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const HeapVector<Member<T>>* value) {
     DCHECK(value);
     return bindings::ToV8HelperSequenceWithMemberUpcast<
         bindings::DictionaryBase>(script_state, value);
   }
 
-  static v8::MaybeLocal<v8::Value> ToV8(
-      ScriptState* script_state,
-      const HeapVector<Member<const T>>* value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const HeapVector<Member<const T>>* value) {
     DCHECK(value);
     return bindings::ToV8HelperSequenceWithMemberUpcast<
         bindings::DictionaryBase>(script_state, value);
   }
 
   // TODO(crbug.com/1185046): Remove this overload.
-  static v8::MaybeLocal<v8::Value> ToV8(
-      ScriptState* script_state,
-      const Vector<v8::Local<v8::Value>>& value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const Vector<v8::Local<v8::Value>>& value) {
     return bindings::ToV8HelperSequence<IDLAny>(script_state, value);
   }
 };
@@ -534,40 +516,35 @@ template <typename T>
 struct ToV8Traits<
     IDLSequence<T>,
     std::enable_if_t<std::is_base_of<IDLDictionaryBase, T>::value>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const HeapVector<Member<T>>& value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const HeapVector<Member<T>>& value) {
     return bindings::ToV8HelperSequenceWithMemberUpcast<IDLDictionaryBase>(
         script_state, &value);
   }
 
-  static v8::MaybeLocal<v8::Value> ToV8(
-      ScriptState* script_state,
-      const HeapVector<Member<const T>>& value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const HeapVector<Member<const T>>& value) {
     return bindings::ToV8HelperSequenceWithMemberUpcast<IDLDictionaryBase>(
         script_state, &value);
   }
 
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const HeapVector<Member<T>>* value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const HeapVector<Member<T>>* value) {
     DCHECK(value);
     return bindings::ToV8HelperSequenceWithMemberUpcast<IDLDictionaryBase>(
         script_state, value);
   }
 
-  static v8::MaybeLocal<v8::Value> ToV8(
-      ScriptState* script_state,
-      const HeapVector<Member<const T>>* value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const HeapVector<Member<const T>>* value) {
     DCHECK(value);
     return bindings::ToV8HelperSequenceWithMemberUpcast<IDLDictionaryBase>(
         script_state, value);
   }
 
   // TODO(crbug.com/1185046): Remove this overload.
-  static v8::MaybeLocal<v8::Value> ToV8(
-      ScriptState* script_state,
-      const Vector<v8::Local<v8::Value>>& value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const Vector<v8::Local<v8::Value>>& value) {
     return bindings::ToV8HelperSequence<IDLAny>(script_state, value);
   }
 };
@@ -576,31 +553,27 @@ template <typename T>
 struct ToV8Traits<
     IDLSequence<T>,
     std::enable_if_t<std::is_base_of<ScriptWrappable, T>::value>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const HeapVector<Member<T>>& value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const HeapVector<Member<T>>& value) {
     return bindings::ToV8HelperSequenceWithMemberUpcast<ScriptWrappable>(
         script_state, &value);
   }
 
-  static v8::MaybeLocal<v8::Value> ToV8(
-      ScriptState* script_state,
-      const HeapVector<Member<const T>>& value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const HeapVector<Member<const T>>& value) {
     return bindings::ToV8HelperSequenceWithMemberUpcast<ScriptWrappable>(
         script_state, &value);
   }
 
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const HeapVector<Member<T>>* value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const HeapVector<Member<T>>* value) {
     DCHECK(value);
     return bindings::ToV8HelperSequenceWithMemberUpcast<ScriptWrappable>(
         script_state, value);
   }
 
-  static v8::MaybeLocal<v8::Value> ToV8(
-      ScriptState* script_state,
-      const HeapVector<Member<const T>>* value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const HeapVector<Member<const T>>* value) {
     DCHECK(value);
     return bindings::ToV8HelperSequenceWithMemberUpcast<ScriptWrappable>(
         script_state, value);
@@ -614,23 +587,21 @@ struct ToV8Traits<
                      !std::is_base_of<IDLDictionaryBase, T>::value &&
                      !std::is_base_of<ScriptWrappable, T>::value>> {
   template <typename VectorType>
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const VectorType& value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const VectorType& value) {
     return bindings::ToV8HelperSequence<T>(script_state, value);
   }
 
   template <typename VectorType>
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const VectorType* value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const VectorType* value) {
     DCHECK(value);
     return bindings::ToV8HelperSequence<T>(script_state, *value);
   }
 
   template <typename VectorType>
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        VectorType* value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, VectorType* value) {
     DCHECK(value);
     return bindings::ToV8HelperSequence<T>(script_state, *value);
   }
@@ -640,9 +611,8 @@ struct ToV8Traits<
 template <typename T>
 struct ToV8Traits<IDLArray<T>> {
   template <typename VectorType>
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const VectorType& value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const VectorType& value) {
     v8::Local<v8::Value> v8_value;
     if (!ToV8Traits<IDLSequence<T>>::ToV8(script_state, value)
              .ToLocal(&v8_value)) {
@@ -654,9 +624,8 @@ struct ToV8Traits<IDLArray<T>> {
   }
 
   template <typename VectorType>
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const VectorType* value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const VectorType* value) {
     DCHECK(value);
     v8::Local<v8::Value> v8_value;
     if (!ToV8Traits<IDLSequence<T>>::ToV8(script_state, *value)
@@ -669,8 +638,8 @@ struct ToV8Traits<IDLArray<T>> {
   }
 
   template <typename VectorType>
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        VectorType* value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, VectorType* value) {
     DCHECK(value);
     v8::Local<v8::Value> v8_value;
     if (!ToV8Traits<IDLSequence<T>>::ToV8(script_state, *value)
@@ -683,9 +652,8 @@ struct ToV8Traits<IDLArray<T>> {
   }
 
   // TODO(crbug.com/1185046): Remove this overload.
-  static v8::MaybeLocal<v8::Value> ToV8(
-      ScriptState* script_state,
-      const Vector<v8::Local<v8::Value>>& value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const Vector<v8::Local<v8::Value>>& value) {
     v8::Local<v8::Value> v8_value;
     if (!ToV8Traits<IDLSequence<IDLAny>>::ToV8(script_state, value)
              .ToLocal(&v8_value)) {
@@ -701,15 +669,15 @@ struct ToV8Traits<IDLArray<T>> {
 // K must be based of IDL String types.
 template <typename K, typename V>
 struct ToV8Traits<IDLRecord<K, V>> {
-  static v8::MaybeLocal<v8::Value> ToV8(
-      ScriptState* script_state,
-      const typename IDLRecord<K, V>::ImplType& value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state,
+       const typename IDLRecord<K, V>::ImplType& value) {
     return bindings::ToV8HelperRecord<V>(script_state, value);
   }
 
-  static v8::MaybeLocal<v8::Value> ToV8(
-      ScriptState* script_state,
-      const typename IDLRecord<K, V>::ImplType* value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state,
+       const typename IDLRecord<K, V>::ImplType* value) {
     DCHECK(value);
     return bindings::ToV8HelperRecord<V>(script_state, *value);
   }
@@ -724,9 +692,8 @@ struct ToV8Traits<IDLNullable<IDLNullable<T>>>;
 // Nullable Boolean
 template <>
 struct ToV8Traits<IDLNullable<IDLBoolean>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const base::Optional<bool>& value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const base::Optional<bool>& value) {
     if (!value)
       return v8::Null(script_state->GetIsolate());
     return ToV8Traits<IDLBoolean>::ToV8(script_state, *value);
@@ -736,9 +703,8 @@ struct ToV8Traits<IDLNullable<IDLBoolean>> {
 // Nullable Integers
 template <typename T, bindings::IDLIntegerConvMode mode>
 struct ToV8Traits<IDLNullable<IDLIntegerTypeBase<T, mode>>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const base::Optional<T>& value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const base::Optional<T>& value) {
     if (!value)
       return v8::Null(script_state->GetIsolate());
     return ToV8Traits<IDLIntegerTypeBase<T, mode>>::ToV8(script_state, *value);
@@ -748,9 +714,8 @@ struct ToV8Traits<IDLNullable<IDLIntegerTypeBase<T, mode>>> {
 // Nullable Floating Point Number
 template <typename T, bindings::IDLFloatingPointNumberConvMode mode>
 struct ToV8Traits<IDLNullable<IDLFloatingPointNumberTypeBase<T, mode>>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const base::Optional<T>& value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const base::Optional<T>& value) {
     if (!value)
       return v8::Null(script_state->GetIsolate());
     return ToV8Traits<IDLFloatingPointNumberTypeBase<T, mode>>::ToV8(
@@ -763,9 +728,8 @@ template <typename T>
 struct ToV8Traits<
     IDLNullable<T>,
     typename std::enable_if_t<std::is_base_of<IDLStringTypeBase, T>::value>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const String& value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const String& value) {
     if (!value)
       return v8::Null(script_state->GetIsolate());
     return ToV8Traits<T>::ToV8(script_state, value);
@@ -775,9 +739,8 @@ struct ToV8Traits<
 // Nullable Object
 template <>
 struct ToV8Traits<IDLNullable<IDLObject>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const ScriptValue& script_value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const ScriptValue& script_value) {
     // TODO(crbug.com/1183637): Remove this if-branch.
     if (script_value.IsEmpty())
       return v8::Null(script_state->GetIsolate());
@@ -793,18 +756,17 @@ template <typename T>
 struct ToV8Traits<
     IDLNullable<T>,
     typename std::enable_if_t<std::is_base_of<ScriptWrappable, T>::value>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        T* script_wrappable)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, T* script_wrappable) {
     if (!script_wrappable)
       return v8::Null(script_state->GetIsolate());
     return ToV8Traits<T>::ToV8(script_state, script_wrappable);
   }
 
-  static v8::MaybeLocal<v8::Value> ToV8(v8::Isolate* isolate,
-                                        ScriptWrappable* script_wrappable,
-                                        v8::Local<v8::Object> creation_context)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(v8::Isolate* isolate,
+       ScriptWrappable* script_wrappable,
+       v8::Local<v8::Object> creation_context) {
     if (!script_wrappable)
       return v8::Null(isolate);
     return ToV8Traits<T>::ToV8(isolate, script_wrappable, creation_context);
@@ -816,9 +778,8 @@ template <typename T>
 struct ToV8Traits<IDLNullable<T>,
                   typename std::enable_if_t<
                       std::is_base_of<bindings::DictionaryBase, T>::value>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const T* dictionary)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const T* dictionary) {
     if (!dictionary)
       return v8::Null(script_state->GetIsolate());
     return ToV8Traits<T>::ToV8(script_state, dictionary);
@@ -830,9 +791,8 @@ template <typename T>
 struct ToV8Traits<
     IDLNullable<T>,
     typename std::enable_if_t<std::is_base_of<IDLDictionaryBase, T>::value>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const T* dictionary)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const T* dictionary) {
     if (!dictionary)
       return v8::Null(script_state->GetIsolate());
     return ToV8Traits<T>::ToV8(script_state, dictionary);
@@ -844,8 +804,8 @@ template <typename T>
 struct ToV8Traits<IDLNullable<T>,
                   typename std::enable_if_t<
                       std::is_base_of<CallbackFunctionBase, T>::value>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        T* callback) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, T* callback) {
     if (!callback)
       return v8::Null(script_state->GetIsolate());
     return ToV8Traits<T>::ToV8(script_state, callback);
@@ -857,8 +817,8 @@ template <typename T>
 struct ToV8Traits<IDLNullable<T>,
                   typename std::enable_if_t<
                       std::is_base_of<CallbackInterfaceBase, T>::value>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        T* callback) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, T* callback) {
     if (!callback)
       return v8::Null(script_state->GetIsolate());
     return ToV8Traits<T>::ToV8(script_state, callback);
@@ -870,9 +830,8 @@ template <typename T>
 struct ToV8Traits<IDLNullable<T>,
                   typename std::enable_if_t<
                       std::is_base_of<bindings::EnumerationBase, T>::value>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const base::Optional<T>& enumeration)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const base::Optional<T>& enumeration) {
     if (!enumeration)
       return v8::Null(script_state->GetIsolate());
     return ToV8Traits<T>::ToV8(script_state, *enumeration);
@@ -882,25 +841,24 @@ struct ToV8Traits<IDLNullable<T>,
 // Nullable NotShared
 template <typename T>
 struct ToV8Traits<IDLNullable<NotShared<T>>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        NotShared<T> value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, NotShared<T> value) {
     if (value.IsNull())
       return v8::Null(script_state->GetIsolate());
     return ToV8Traits<NotShared<T>>::ToV8(script_state, value);
   }
 
   // TODO(crbug.com/1183647): Remove this overload.
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        T* value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, T* value) {
     if (!value)
       return v8::Null(script_state->GetIsolate());
     return ToV8Traits<NotShared<T>>::ToV8(script_state, value);
   }
 
   // TODO(canonmukai): Remove this overload.
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const ScriptValue& script_value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const ScriptValue& script_value) {
     if (script_value.IsEmpty())
       return v8::Null(script_state->GetIsolate());
     return ToV8Traits<NotShared<T>>::ToV8(script_state, script_value);
@@ -910,9 +868,8 @@ struct ToV8Traits<IDLNullable<NotShared<T>>> {
 // Nullable MaybeShared
 template <typename T>
 struct ToV8Traits<IDLNullable<MaybeShared<T>>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        MaybeShared<T> value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, MaybeShared<T> value) {
     if (value.IsNull())
       return v8::Null(script_state->GetIsolate());
     return ToV8Traits<MaybeShared<T>>::ToV8(script_state, value);
@@ -922,18 +879,17 @@ struct ToV8Traits<IDLNullable<MaybeShared<T>>> {
 // Nullable Sequence
 template <typename T>
 struct ToV8Traits<IDLNullable<IDLSequence<T>>> {
-  static v8::MaybeLocal<v8::Value> ToV8(
-      ScriptState* script_state,
-      const base::Optional<typename IDLSequence<T>::ImplType>& value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state,
+       const base::Optional<typename IDLSequence<T>::ImplType>& value) {
     if (!value)
       return v8::Null(script_state->GetIsolate());
     return ToV8Traits<IDLSequence<T>>::ToV8(script_state, *value);
   }
 
-  static v8::MaybeLocal<v8::Value> ToV8(
-      ScriptState* script_state,
-      const typename IDLSequence<T>::ImplType* value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state,
+       const typename IDLSequence<T>::ImplType* value) {
     if (!value)
       return v8::Null(script_state->GetIsolate());
     return ToV8Traits<IDLSequence<T>>::ToV8(script_state, value);
@@ -943,18 +899,16 @@ struct ToV8Traits<IDLNullable<IDLSequence<T>>> {
 // Nullable Frozen Array
 template <typename T>
 struct ToV8Traits<IDLNullable<IDLArray<T>>> {
-  static v8::MaybeLocal<v8::Value> ToV8(
-      ScriptState* script_state,
-      const base::Optional<typename IDLArray<T>::ImplType>& value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state,
+       const base::Optional<typename IDLArray<T>::ImplType>& value) {
     if (!value)
       return v8::Null(script_state->GetIsolate());
     return ToV8Traits<IDLArray<T>>::ToV8(script_state, *value);
   }
 
-  static v8::MaybeLocal<v8::Value> ToV8(
-      ScriptState* script_state,
-      const typename IDLArray<T>::ImplType* value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const typename IDLArray<T>::ImplType* value) {
     if (!value)
       return v8::Null(script_state->GetIsolate());
     return ToV8Traits<IDLArray<T>>::ToV8(script_state, value);
@@ -964,18 +918,17 @@ struct ToV8Traits<IDLNullable<IDLArray<T>>> {
 // Nullable Record
 template <typename K, typename V>
 struct ToV8Traits<IDLNullable<IDLRecord<K, V>>> {
-  static v8::MaybeLocal<v8::Value> ToV8(
-      ScriptState* script_state,
-      const base::Optional<typename IDLRecord<K, V>::ImplType>& value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state,
+       const base::Optional<typename IDLRecord<K, V>::ImplType>& value) {
     if (!value)
       return v8::Null(script_state->GetIsolate());
     return ToV8Traits<IDLRecord<K, V>>::ToV8(script_state, *value);
   }
 
-  static v8::MaybeLocal<v8::Value> ToV8(
-      ScriptState* script_state,
-      const typename IDLRecord<K, V>::ImplType* value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state,
+       const typename IDLRecord<K, V>::ImplType* value) {
     if (!value)
       return v8::Null(script_state->GetIsolate());
     return ToV8Traits<IDLRecord<K, V>>::ToV8(script_state, value);
@@ -986,9 +939,8 @@ struct ToV8Traits<IDLNullable<IDLRecord<K, V>>> {
 // IDLDate must be used as IDLNullable<IDLDate>.
 template <>
 struct ToV8Traits<IDLNullable<IDLDate>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const base::Optional<base::Time> date)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const base::Optional<base::Time> date) {
     if (!date)
       return v8::Null(script_state->GetIsolate());
     return v8::Date::New(script_state->GetContext(),
@@ -1014,8 +966,8 @@ inline v8::MaybeLocal<v8::Value> ToV8HelperUnion(ScriptState* script_state,
 // IDLUnionINT
 template <typename T>
 struct ToV8Traits<IDLUnionINT<T>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const T& value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const T& value) {
     return bindings::ToV8HelperUnion(script_state, value);
   }
 };
@@ -1023,8 +975,8 @@ struct ToV8Traits<IDLUnionINT<T>> {
 // IDLUnionNotINT
 template <typename T>
 struct ToV8Traits<IDLUnionNotINT<T>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const T& value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const T& value) {
     return bindings::ToV8HelperUnion(script_state, value);
   }
 };
@@ -1036,8 +988,8 @@ struct ToV8Traits<IDLNullable<IDLUnionINT<T>>>;
 // Nullable IDLUnionNotINT
 template <typename T>
 struct ToV8Traits<IDLNullable<IDLUnionNotINT<T>>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const T& value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const T& value) {
     if (value.IsNull())
       return v8::Null(script_state->GetIsolate());
     return ToV8Traits<IDLUnionNotINT<T>>::ToV8(script_state, value);
@@ -1047,16 +999,15 @@ struct ToV8Traits<IDLNullable<IDLUnionNotINT<T>>> {
 // Optional
 template <typename T>
 struct ToV8Traits<IDLOptional<T>> {
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const T* value) WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const T* value) {
     if (!value)
       return v8::Undefined(script_state->GetIsolate());
     return ToV8Traits<T>::ToV8(script_state, value);
   }
 
-  static v8::MaybeLocal<v8::Value> ToV8(ScriptState* script_state,
-                                        const ScriptValue& value)
-      WARN_UNUSED_RESULT {
+  static v8::MaybeLocal<v8::Value> WARN_UNUSED_RESULT
+  ToV8(ScriptState* script_state, const ScriptValue& value) {
     if (value.IsEmpty())
       return v8::Undefined(script_state->GetIsolate());
     return ToV8Traits<T>::ToV8(script_state, value);
-- 
2.26.2

